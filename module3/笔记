1、不论用什么方法编程，都须谨记：
    写重复代码是非常不好的低级行为
    所写的代码，日后需要经常变更

2、面向对象编程：<多个函数需要传入多个共同的参数、创建模版>
    Class类： 对具有相同属性的对象的抽象
    Object对象： 一个类实例化后的实例，一个类可以实例化多个对象，每个对象可以有不同的属性
    Encapsulation封装： 在类中对数据的赋值、内部调用，对外部用户是透明的，这使类变成了一个胶囊或容器，里面包含着类的数据和方法
    Inheritance继承： 一个类可以派生出子类，在这个父类中定义的属性、方法自动被子类继承
    Polymorphism多态： "一个接口，多种实现"，指一个基类中派生出了不同的子类，且每个子类在继承了同样的方法名的同时又对父类的方法
                    做了不同的实现，这就是同一种事物表现出的多种形态

3、 实例化：
    class Person(object):
        author = 'bloke'    # 公有属性，保存在类中
        def __init__(self, name):   # 其中的self是实例本身
            self.name = name
        def talk(self, content): # content为普通字段，普通字段的值保存在对象中
            print(content)
    执行：r1 = Person('bloke') # 这个赋值的过程就是实例化，将一个虚拟的抽象的类，通这过个动作，变成一个真实的对象，此对象叫做实例

4、staticmethod 静态属性
    class A(object):
        @staticmethod   # 不需要实例化就可调用，例如: A.author()
        def author():   # 此方法，没有实际的意义，对象在调用时会保存在对象中，浪费资源，应该写成静态方法<@staticmethod>
            print('Author :', author)

5、 @property 属性函数:一个将类方法变为类属性的装饰器
        a、可以直接使用点号去访问类方法
        b、可以通过点号['.']访问类方法
        c、重构类方法的setter、getter
        例如：
            class Person(object):
                def __init__(self, name, age):
                    self.name = name
                    self.age = age

                @property
                def info(self):
                    return('Name: %s, Age: %s' % (self.name, self.age))

                @info.setter
                def info(self, name):
                    self.name = name
                    return('Name: %s, Age: %s.' % (self.name, self.age))

                @info.deleter
                def info(self):
                    del self.age

            person = Person('bloke', '22')  # 实例化
            print(person.info)      # Name: bloke, Age: 22
            person.info = 'user01'
            print(person.info)      # Name: user01, Age: 22
            del person.info         # 删除age
            print(person.info)      # 抛出异常，没有age属性
            # 在不动源代码构造结构时，将获取信息、修改信息、删除信息封装成一个接口，以供调用
            # 也可以使用:   info = property(get, set, del)   将类的get、set、del方法封装成info接口

6、类特殊方法：
    1、样例代码 <__call__、__getitem__、__setitem__、__delitem__>:
        class Person(object):
        """
        自定义Person类
        """
        def __init__(self, name):
            self.name = name

        def __call__(self):
            print('My name is %s.' % self.name)

        def __getitem__(self, item):
            print('%s: [ %s ].' % (item, self.item))

        def __setitem__(self, key, value):
            print('Set %s : [ %s ].' % (key, value))
            self.name = value

        def __delitem__(self, key):
            print('Delete %s.' % key)
            del key

        person = Person('bloke')    # 实例化
        person()    # 调用__call__
        person['name'] = 'user01'   # 调用__setitem__
        del(person['name'])         # 调用__delitem__

7、反射：
    hasattr(obj, attr)      # 判断obj是否有attr属性
    getattr(obj, attr, default)      # 获取obj的attr属性，默认输出default
    delattr(obj, attr)      # 删除obj的attr属性
    setattr(obj, attr, value)     # 设置obj的attr属性的值为value

8、
